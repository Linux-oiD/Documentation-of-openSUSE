<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<!-- fs 2010-07-10: 

http://wiki.ubuntuusers.de/virsh
http://wiki.libvirt.org/page/TLSSetup
http://wiki.libvirt.org/page/VNCTLSSetu
-->
<chapter id="cha.libvirt.connect">
 <title>Connecting and Authorizing</title>
 <para>
  Having to manage several &vmhost;s, each hosting a couple of &vmguest;s,
  quickly becomes difficult to handle. One of the major benefits of
  &libvirt; is the ability to connect to several &vmhost;s at once,
  providing a single interface to manage all &vmguest;s and to connect to
  their graphical console.
 </para>
 <para>
  In order to ensure only authorized users can connect, &libvirt; offers
  several connection types that can be combined with different authorization
  mechanisms.
 </para>
 <sect1 id="sec.libvirt.connect.auth">
  <title>Authentication</title>

  <para>
   The power to manage &vmguest;s and to access their graphical console
   obviously is something that should be restricted to a well defined circle
   of persons. In order to achieve this goal, you can use the following
   authentication techniques on the &vmhost;:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Access control for UNIX sockets with permissions and group ownership.
     This method is available for &libvirtd; connections only.
    </para>
   </listitem>
   <listitem>
    <para>
     Access control for UNIX sockets with &pk;. This method is available for
     local &libvirtd; connections only.
    </para>
   </listitem>
   <listitem>
    <para>
     Username and password authentication with SASL (Simple Authentication
     and Security Layer). This method is available for both, &libvirtd; and
     VNC connections. Using SASL does not require real user accounts on the
     server, since it uses its own database to store usernames and
     passwords.
    </para>
   </listitem>
   <listitem>
    <para>
     Kerberos authentication. This method, available for &libvirtd;
     connections only, is not covered in this manual. Please refer to
     <ulink
      url="http://libvirt.org/auth.html#ACL_server_kerberos"/>
     for details.
    </para>
   </listitem>
   <listitem>
    <para>
     Single password authentication. This method is available for VNC
     connections only.
    </para>
   </listitem>
  </itemizedlist>

  <important>
   <title>Authentication for &libvirtd; and VNC need to be configured separately</title>
   <para>
    Access to the &vmguest; management functions (via &libvirtd;) on the one
    hand and to their graphical console on the other hand, always needs to
    be configured separately. When restricting the access to the management
    tools, these restrictions do <emphasis>not</emphasis> automatically
    apply to VNC connections!
   </para>
  </important>

  <para>
   When accessing &vmguest;s from remote via TLS/SSL connections, access can
   be indirectly controlled on each client by restricting read permissions
   to the certificate's key file to a certain group. See
   <xref
    linkend="sec.libvirt.connect.remote.tls.security"/> for
   details.
  </para>

  <sect2 id="sec.libvirt.connect.auth.libvirt">
   <title>&libvirtd; Authentication</title>
   <para>
    &libvirtd; authentication is configured in
    <filename>/etc/libvirt/libvirtd.conf</filename>. The configuration made
    here applies to all &libvirt; tools such as the &vmm; or
    <command>virsh</command>.
   </para>
   <para>
    &libvirt; offers two sockets: a read-only socket for monitoring purposes
    and a read-write socket to be used for management operations. Access to
    both sockets can be configured independently. By default, both sockets
    are owned by <literal>root.root</literal>. Default access permissions on
    the read-write socket are restricted to the user &rootuser;
    (<literal>0700</literal>) and fully open on the read-only socket
    (<literal>0777</literal>).
   </para>
   <para>
    In the following instructions you learn how to configure access
    permissions for the read-write socket. The same instructions also apply
    to the read-only socket. All configuration steps have to be carried out
    on the &vmhost;.
   </para>
   <note>
    <title>Default Authentication Settings on &productname;</title>
    <para>
     The default authorization method on &productname; is access control for
     UNIX sockets with &pk;. Every user accessing the read-write socket, has
     to provide the &rootuser; password once and is granted access for the
     current and for future sessions.
    </para>
   </note>
   <variablelist>
    <title>Recommended Authorization Methods</title>
    <varlistentry>
     <term>Local Connections</term>
     <listitem>
      <simplelist>
       <member><xref linkend="sec.libvirt.connect.auth.libvirt.pk"/>
       </member>
       <member><xref linkend="sec.libvirt.connect.auth.libvirt.traditional"/>
       </member>
      </simplelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Remote Tunnel over SSH</term>
     <listitem>
      <simplelist>
       <member><xref linkend="sec.libvirt.connect.auth.libvirt.traditional"/>
       </member>
      </simplelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Remote TLS/SSL Connection</term>
     <listitem>
      <simplelist>
       <member><xref linkend="sec.libvirt.connect.auth.libvirt.sasl"/>
       </member>
       <member>none (access controlled on the client side by restricting
	access to the certificates)</member>
      </simplelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <sect3 id="sec.libvirt.connect.auth.libvirt.traditional">
    <title>Access Control for UNIX Sockets with Permissions and Group Ownership</title>
    <para>
     In order to grant access for non-&rootuser; accounts, configure the
     sockets to be owned and accessible by a certain group
     (<systemitem
      class="groupname">libvirt</systemitem> in the
     following example). This authentication method can be used for local
     and remote SSH connections.
    </para>
    <procedure>
     <step>
      <para>
       In case it does not exist, create the group which should own the
       socket:
      </para>
<screen>groupadd libvirt</screen>
      <important>
       <title>Group Needs to Exist</title>
       <para>
        The group must exist prior to restarting &libvirtd;. If not, the
        restart will fail.
       </para>
      </important>
     </step>
     <step>
      <para>
       Add the desired users to the group:
      </para>
<screen>usermod -A libvirt &exampleuser;</screen>
     </step>
     <step>
      <para>
       Change the configuration in
       <filename>/etc/libvirt/libvirtd.conf</filename> as follows:
      </para>
<screen>
       unix_sock_group = "libvirt"<co id="co.libvirt.connect.ssh.group"/>
       unix_sock_rw_perms = "0770"<co id="co.libvirt.connect.ssh.perms"/>
       auth_unix_rw = "none"<co id="co.libvirt.connect.ssh.enable"/>
      </screen>
      <calloutlist>
       <callout arearefs="co.libvirt.connect.ssh.group">
        <para>
         Group ownership will be set to group <literal>libvirt</literal>.
        </para>
       </callout>
       <callout arearefs="co.libvirt.connect.ssh.perms">
        <para>
         Sets the access permissions for the socket (srwxrwx---).
        </para>
       </callout>
       <callout arearefs="co.libvirt.connect.ssh.enable">
        <para>
         Disables other authentication methods (&pk; or SASL). Access is
         solely controlled by the socket permissions.
        </para>
       </callout>
      </calloutlist>
     </step>
     <step>
      <para>
       Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 id="sec.libvirt.connect.auth.libvirt.pk">
    <title>Access Control for UNIX Sockets with &pk;</title>
<!-- fs 2010-11-12:
     SLE 11 SP1 uses the old PolicyKit version. polkit1 (from openSUSE 11.3
     onwards) also supports group authentication
      http://wiki.libvirt.org/page/SSHPolicyKitSetup
-->
    <para>
     Access control for UNIX sockets with &pk; is the default authentication
     method on &productname;. Therefore, no &libvirt; configuration changes
     are needed. With &pk; authorization enabled, permissions on both
     sockets default to <literal>0777</literal> and each application trying
     to access a socket needs to authenticate via &pk;. &productname;
     currently supports this method for local connections only.
<!--
     https://bugzilla.novell.com/show_bug.cgi?id=652371 -->
    </para>
    <para>
     Two policies for accessing &libvirt;'s sockets exist:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <emphasis>org.libvirt.unix.monitor</emphasis>: accessing the
       read-only socket
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>org.libvirt.unix.manage</emphasis>: accessing the
       read-write socket
      </para>
     </listitem>
    </itemizedlist>
    <para>
     By default, the policy for accessing the read-write socket is to
     authenticate with &rootuser; password once and grant the privilege for
     the current and for future sessions (auth_admin_keep_always).
    </para>
    <para>
     In order to grant users access to the read-write socket without having
     to provide the &rootuser; password, there are two possibilities:
    </para>
    <orderedlist>
     <listitem>
      <para>
       Using the <command>polkit-auth</command> command, you can grant the
       privilege without any restrictions:
      </para>
<screen>polkit-auth --user &exampleuser; --grant org.libvirt.unix.manage    # grant privilege
polkit-auth --user &exampleuser; --revoke org.libvirt.unix.manage   # revoke privilege</screen>
     </listitem>
     <listitem>
      <para>
       Editing <filename>/etc/PolicyKit/PolicyKit.conf</filename> offers
       more advanced options. Add the following XML snippet in between the
       existing <literal>&lt;config version="0.1"&gt;</literal> and
       <literal>&lt;/config&gt;</literal> tags:
      </para>
<screen>&lt;match action="org.libvirt.unix.manage"&gt;<co id="co.libvirt.pk.action"/>
  &lt;match user="&exampleuser;"&gt;<co id="co.libvirt.pk.user"/>
    &lt;return result="yes"/&gt;<co id="co.libvirt.pk.priv"/>
  &lt;/match&gt;
&lt;/match&gt;</screen>
      <calloutlist>
       <callout arearefs="co.libvirt.pk.action">
        <para>
         The name of the policy; <literal>org.libvirt.unix.manage</literal>
         stands for accessing the read-write socket.
        </para>
       </callout>
       <callout arearefs="co.libvirt.pk.user">
        <para>
         The username(s) which to grant the privilege. Use the
         <literal>|</literal> symbol to separate entries
         (<literal>user="&exampleuser;|&exampleuserII;"</literal>).
        </para>
       </callout>
       <callout arearefs="co.libvirt.pk.priv">
        <para>
         The privilege that is granted. The following options exist:
         <literal>yes</literal> (no restrictions), <literal>no</literal>
         (block access completely), <literal>auth_self</literal> or
         <literal>auth_admin</literal> (authenticate with own
         password/&rootuser; password every time the privilege is
         requested), <literal>auth_self_keep_session</literal> or
         <literal>auth_admin_keep_session</literal> (authenticate with own
         password/&rootuser; password once per session) and
         <literal>auth_self_keep_always</literal> or
         <literal>auth_admin_keep_always</literal> (authenticate only once
         with own password/&rootuser; password).
        </para>
       </callout>
      </calloutlist>
     </listitem>
    </orderedlist>
   </sect3>
   <sect3 id="sec.libvirt.connect.auth.libvirt.sasl">
    <title>Username and Password Authentication with SASL</title>
    <para>
     SASL provides username and password authentication as well as data
     encryption (digest-md5, by default). Since SASL maintains its own user
     database, the users do not need to exist on the &vmhost;. SASL is
     required by TCP connections and on top of TLS/SSL connections.
    </para>
    <important>
     <title>Plain TCP and SASL with digest-md5 Encryption</title>
     <para>
      Using digest-md5 encryption on an otherwise unencrypted TCP connection
      does not provide enough security for production environments. It is
      recommended to only use it in testing environments.
     </para>
    </important>
    <tip>
     <title>SASL Authentication on Top of TLS/SSL</title>
     <para>
      Access from remote TLS/SSL connections can be indirectly controlled on
      the <emphasis>client side</emphasis> by restricting access to the
      certificate's key file. However, this might prove error-prone when
      dealing with a large number of clients. Utilizing SASL with TLS adds
      security by additionally controlling access on the server side.
     </para>
    </tip>
    <para>
     To configure SASL authentication, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Change the configuration in
       <filename>/etc/libvirt/libvirtd.conf</filename> as follows:
      </para>
      <substeps>
       <step>
        <para>
         To enable SASL for TCP connections:
        </para>
<screen>auth_tcp = "sasl"</screen>
       </step>
       <step>
        <para>
         To enable SASL for TLS/SSL connections:
        </para>
<screen>auth_tls = "sasl"</screen>
       </step>
      </substeps>
     </step>
     <step>
      <para>
       Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
     <step>
      <para>
       The libvirt SASL configuration file is located at
       <filename>/etc/sasl2/libvirtd.conf</filename>. Normally, there is no
       need to change the defaults. However, if using SASL on top of TLS,
       you may turn off session encryption to avoid additional
       overhead&mdash; TLS connections are already encrypted&mdash; by
       commenting the <literal>mech_list</literal>. For TCP connections this
       parameter must be set to digest-md5:
      </para>
<screen>mech_list: digest-md5   # mandatory for TCP connections
#mech_list: digest-md5   # apply default (username+password) TLS/SSL only!</screen>
     </step>
     <step>
      <para>
       By default, no SASL users are configured, so no logins are possible.
       Use the following commands to add, list, and delete users:
      </para>
<screen>&wsIV;:~ # saslpasswd2 -a libvirt &exampleuser;                  # add user &exampleuser;
Password: 
Again (for verification): 
&wsIV;:~ # sasldblistusers2 -f /etc/libvirt/passwd.db  # list users
&exampleuser;@&wsIVname;: userPassword
&wsIV;:~ # saslpasswd2 -a libvirt -d &exampleuser;               # delete user &exampleuser;</screen>
     </step>
    </procedure>
    <tip>
     <title><command>virsh</command> and SASL Authentication</title>
     <para>
      When using SASL authentication you will be prompted for a username and
      password every time you issue a <command>virsh</command> command.
      Avoid this by using <command>virsh</command> in shell mode.
     </para>
    </tip>
   </sect3>
  </sect2>

  <sect2 id="sec.libvirt.connect.auth.vnc">
   <title>VNC Authentication</title>
   <para>
    Since access to the graphical console of a &vmguest; is not controlled
    by &libvirt;, but rather by <literal>&qemu;</literal>, it is always
    necessary to additionally configure VNC authentication. The main
    configuration file is <filename>/etc/libvirt/qemu.conf</filename>.
   </para>
   <para>
    Two authentication types are available: SASL and single password
    authentication. If you are using SASL for &libvirt; authentication, it
    is strongly recommended to use it for VNC authentication as
    well&mdash;it is possible to share the same database.
   </para>
   <para>
    A third method to restrict access to the &vmguest; is to enable the use
    of TLS encryption on the VNC server. This requires the VNC clients to
    have access to x509 client certificates. By restricting access to these
    certificates, access can indirectly be controlled on the client side.
    Refer to <xref linkend="sec.libvirt.connect.remote.tls.vnc.client"/> for
    details.
   </para>
   <sect3 id="sec.libvirt.connect.auth.vnc.tls">
    <title>Username and Password Authentication with SASL</title>
    <para>
     SASL provides username and password authentication as well as data
     encryption. Since SASL maintains its own user database, the users do
     not need to exist on the &vmhost;. As with SASL authentication for
     &libvirt;, you may use SASL on top of TLS/SSL connections. Refer to
     <xref
      linkend="sec.libvirt.connect.remote.tls.vnc.client"/> for
     details on configuring these connections.
    </para>
    <para>
     To configure SASL authentication for VNC, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Create a SASL configuration file. It is recommended to use the
       existing &libvirt; file. If you have already configured SASL for
       &libvirt; and are planning to use the same settings including the
       same username/password database, a simple link is suitable:
      </para>
<screen>ln -s /etc/sasl2/libvirt.conf /etc/sasl2/qemu.conf</screen>
      <para>
       In case you are setting up SASL for VNC only or planning to use a
       different configuration than for &libvirt;, copy the existing file to
       use as a template and edit it according to your needs:
      </para>
<screen>cp /etc/sasl2/libvirt.conf /etc/sasl2/qemu.conf</screen>
     </step>
     <step>
      <para>
       By default, no SASL users are configured, so no logins are possible.
       Use the following commands to add, list, and delete users:
      </para>
<screen>&wsIV;:~ # saslpasswd2 -a libvirt &exampleuser;                  # add user &exampleuser;
Password: 
Again (for verification): 
&wsIV;:~ # sasldblistusers2 -f /etc/libvirt/passwd.db  # list users
&exampleuser;@&wsIVname;: userPassword
&wsIV;:~ # saslpasswd2 -a libvirt -d &exampleuser;               # delete user &exampleuser;</screen>
     </step>
     <step>
      <para>
       Change the configuration in
       <filename>/etc/libvirt/qemu.conf</filename> as follows:
      </para>
<screen>vnc_listen = "0.0.0.0"
vnc_sasl = 1</screen>
      <para>
       The first parameter enables VNC to listen on all public interfaces
       (rather than to the local host only), and the second parameter
       enables SASL authentication.
      </para>
     </step>
     <step>
      <para>
       Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
     <step>
      <para>
       Restart all &vmguest;s that have been running prior to changing the
       configuration. &vmguest;s that have not been restarted will not use
       SASL authentication for VNC connects.
      </para>
     </step>
    </procedure>
    <note>
     <title>Supported VNC Viewers</title>
     <para>
      Currently only the same VNC viewers that also support TLS/SSL
      connections, support SASL authentication, namely &vmm;,
      <command>virt-viewer</command>, and <command>vinagre</command>.
     </para>
    </note>
   </sect3>
   <sect3 id="sec.libvirt.connect.auth.vnc.pw">
    <title>Single Password Authentication</title>
    <para>
     Access to the VNC server may also be controlled by setting a VNC
     password. You can either set a global password for all &vmguest;s or
     set individual passwords for each guest. The latter requires to edit
     the &vmguest;'s config files.
    </para>
    <note>
     <title>Always Set a Global Password</title>
     <para>
      If you are using the single password authentication, it is good
      practice to set a global password even if setting passwords for each
      &vmguest;. This will always leave your virtual machines protected with
      a <quote>fallback</quote> password if you forget to set a per-machine
      password. The global password will only be used if no other password
      is set for the machine.
     </para>
    </note>
    <procedure>
     <title>Setting a Global VNC Password</title>
     <step>
      <para>
       Change the configuration in
       <filename>/etc/libvirt/qemu.conf</filename> as follows:
      </para>
<screen>vnc_listen = "0.0.0.0"
       vnc_password = "<replaceable>PASSWORD</replaceable>"</screen>
      <para>
       The first parameter enables VNC to listen on all public interfaces
       (rather than to the local host only), and the second parameter sets
       the password. The maximum length of the password is eight characters.
      </para>
     </step>
     <step>
      <para>
       Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
     <step>
      <para>
       Restart all &vmguest;s that have been running prior to changing the
       configuration. &vmguest;s that have not been restarted will not use
       password authentication for VNC connects.
      </para>
     </step>
    </procedure>
    <procedure>
     <title>Setting a &vmguest; Specific VNC Password</title>
     <step>
      <para>
       Change the configuration in
       <filename>/etc/libvirt/qemu.conf</filename> as follows to enable VNC
       to listen on all public interfaces (rather than to the local host
       only).
      </para>
<screen>vnc_listen = "0.0.0.0"</screen>
     </step>
     <step>
      <para>
       Open the &vmguest;'s XML configuration file in an editor. Replace
       <replaceable>VM NAME</replaceable> in the following example with the
       name of the &vmguest;. The editor that is used defaults to
       <envar>$EDITOR</envar>. If that variable is not set,
       <command>vi</command> is used.
      </para>
<screen>virsh edit <replaceable>VM NAME</replaceable></screen>
     </step>
     <step>
      <para>
       Search for the element <literal>&lt;graphics&gt;</literal> with the
       attribute <literal>type='vnc'</literal>, for example:
      </para>
<screen>&lt;graphics type='vnc' port='-1' autoport='yes'/&gt;</screen>
     </step>
     <step>
      <para>
       Add the <literal>passwd=<replaceable>PASSWORD</replaceable></literal>
       attribute, save the file and leave the editor. The maximum length of
       the password is eight characters.
      </para>
<screen>&lt;graphics type='vnc' port='-1' autoport='yes' passwd='PASSWORD'/&gt;</screen>
     </step>
     <step>
      <para>
       Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
     <step>
      <para>
       Restart all &vmguest;s that have been running prior to changing the
       configuration. &vmguest;s that have not been restarted will not use
       password authentication for VNC connects.
      </para>
     </step>
    </procedure>
    <warning>
     <title>Security</title>
     <para>
      The VNC protocol is not considered to be safe. Although the password
      is sent encrypted, it might be vulnerable, when an attacker is able to
      sniff both, the encrypted password and the encryption key. Therefore,
      it is recommended to use VNC with TLS/SSL or tunneled over SSH.
      <command>virt-viewer</command>, as well as the &vmm; and
      <command>vinagre</command> from version 2.30 on, support both methods.
     </para>
    </warning>
   </sect3>
  </sect2>
 </sect1>
 <sect1 id="sec.libvirt.connect.remote">
  <title>Configuring Remote Connections</title>

  <para>
   A major benefit of &libvirt; is the ability to manage &vmguest;s on
   different remote hosts from a central location. This section gives
   detailed instructions on how to configure server and client to allow
   remote connections.
  </para>

  <sect2 id="sec.libvirt.connect.remote.ssh">
   <title>Remote Tunnel over SSH</title>
   <para>
    Enabling a remote connection that is tunneled over SSH on the &vmhost;
    only requires the ability to accept SSH connections. Make sure the SSH
    daemon is started (<command>rcsshd status</command>) and that the ports
    for service <systemitem class="service">SSH</systemitem> are opened in
    the firewall.
   </para>
<!-- fs 2010-11-11:
     Default authorization on SLES 11 SP1 is PolicyKit. However, this is
     buggy over SSH:
     https://bugzilla.novell.com/show_bug.cgi?id=652371
-->
   <para>
    User authentication for SSH connections can be done using traditional
    file user/group ownership and permissions as described in
    <xref
     linkend="sec.libvirt.connect.auth.libvirt.traditional"/>.
   </para>
  </sect2>

  <sect2 id="sec.libvirt.connect.remote.tls">
   <title>Remote TLS/SSL Connection with x509 Certificate</title>
   <para>
    Using TCP connections with TLS/SSL encryption and authentication via
    x509 certificates is much more complicated to set up than SSH, but it is
    a lot more scalable. Use this method if you have to manage several
    &vmhost;s with a varying number of administrators.
   </para>
   <sect3 id="sec.libvirt.connect.remote.tls.concept">
    <title>Basic concept</title>
    <para>
     Basically, TLS (Transport Layer Security) encrypts the communication
     between two computers by using certificates. The computer starting the
     connection is always considered as the <quote>client</quote> using a
     <quote>client certificate</quote>, while the receiving computer is
     always considered as the <quote>server</quote>, using a <quote>server
     certificate</quote>. This scenario applies, for example, if you manage
     your &vmhost;s from a central desktop.
    </para>
    <para>
     If connections are initiated from both computers, each needs to have a
     client <emphasis>and</emphasis> a server certificate. This is the case,
     for example, if you migrate a &vmguest; from one host to another.
    </para>
    <para>
     Each x509 certificate has a matching private key file. Only the
     combination of certificate and private key file is able to identify
     itself correctly. In order to assure that a certificate was issued by
     the assumed owner, it is signed and issued by a central certificate
     called certification authority (CA). Both the client and the server
     certificates must be issued by the same CA.
    </para>
    <important>
     <title>User Authentication</title>
     <para>
      Using a remote TLS/SSL connection basically only ensures that two
      computers are allowed to communicate in a certain direction.
      Restricting access to certain users can indirectly be achieved on the
      client side by restricting access to the certificates. Refer to
      <xref
       linkend="sec.libvirt.connect.remote.tls.security"/> for
      details. &libvirt; also supports user authentication on the server
      with SASL. Read more in
      <xref
       linkend="sec.libvirt.connect.remote.tls.sasl"/>.
     </para>
    </important>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.server">
    <title>Configuring the &vmhost;</title>
    <para>
     The &vmhost; is the machine receiving connections. Therefore, the
     <emphasis>server</emphasis> certificates have to be installed. The CA
     certificate needs to be installed, as well. Once the certificates are
     in place, TLS support can be turned on for &libvirt;.
    </para>
    <procedure>
     <step>
      <para>
       Create the server certificate and export it together with the CA
       certificate as described in <xref linkend="app.kvm.certificates"/>.
      </para>
     </step>
     <step>
      <para>
       Create the following directories on the &vmhost;:
      </para>
<screen>mkdir -p /etc/pki/CA/ /etc/pki/libvirt/private/</screen>
      <para>
       Install the certificates as follows:
      </para>
<screen>/etc/pki/CA/cacert.pem
/etc/pki/libvirt/servercert.pem
/etc/pki/libvirt/private/serverkey.pem</screen>
      <important>
       <title>Restrict Access to Certificates</title>
       <para>
        Make sure to restrict access to certificates as explained in
        <xref linkend="sec.libvirt.connect.remote.tls.security"/>.
       </para>
      </important>
     </step>
     <step>
      <para>
       Enable TLS support by editing
       <filename>/etc/libvirt/libvirtd.conf</filename> and setting
       <literal>listen_tls = 1</literal>. Restart &libvirtd;:
      </para>
<screen>rclibvirtd restart</screen>
     </step>
     <step>
      <para>
       By default, &libvirt; uses the TCP port 16514 for accepting secure
       TLS connections. Open this port in the firewall.
      </para>
     </step>
    </procedure>
    <important>
     <title>Restarting &libvirtd; with TLS enabled</title>
     <para>
      If you enable TLS for &libvirt;, the server certificates need to be in
      place, otherwise restarting &libvirtd; will fail. You also need to
      restart &libvirtd; in case you change the certificates.
     </para>
    </important>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.client">
    <title>Configuring the Client and Testing the Setup</title>
    <para>
     The client is the machine initiating connections. Therefore the
     <emphasis>client</emphasis> certificates have to be installed. The CA
     certificate needs to be installed, as well.
    </para>
    <procedure>
     <step>
      <para>
       Create the client certificate and export it together with the CA
       certificate as described in <xref linkend="app.kvm.certificates"/>.
      </para>
     </step>
     <step>
      <para>
       Create the following directories on the client:
      </para>
<screen>mkdir -p /etc/pki/CA/ /etc/pki/libvirt/private/</screen>
      <para>
       Install the certificates as follows:
      </para>
<screen>/etc/pki/CA/cacert.pem
/etc/pki/libvirt/clientcert.pem
/etc/pki/libvirt/private/clientkey.pem</screen>
      <important>
       <title>Restrict Access to Certificates</title>
       <para>
        Make sure to restrict access to certificates as explained in
        <xref linkend="sec.libvirt.connect.remote.tls.security"/>.
       </para>
      </important>
     </step>
     <step>
      <para>
       Test the client/server setup by issuing the following command.
       Replace <replaceable>&wsIVname;</replaceable> with the name of your
       &vmhost;. Specify the same full qualified hostname as used when
       creating the server certificate.
      </para>
<screen>virsh -c qemu+tls://<replaceable>&wsIVname;</replaceable>/system list --all</screen>
      <para>
       If your setup is correct, you will see a list of all &vmguest;s
       registered with &libvirt; on the &vmhost;.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.vnc">
    <title>Enabling VNC for TLS/SSL connections</title>
    <para>
     Currently, VNC communication over TLS is only supported by few tools.
     The widespread <command>tightvnc</command> or
     <command>tigervnc</command> viewer, for example, do not support TLS.
     Known to work are the &vmm; (<command>virt-manager</command>),
     <command>virt-viewer</command> and the GNOME VNC viewer
     <command>vinagre</command>.
    </para>
    <sect4 id="sec.libvirt.connect.remote.tls.vnc.server">
     <title>VNC over TLS/SSL: &vmhost; Configuration</title>
     <para>
      In order to access the graphical console via VNC over TLS/SSL, you
      need to configure the &vmhost; as follows:
     </para>
     <procedure>
      <step>
       <para>
        Open ports for the service
        <systemitem class="service">VNC</systemitem> in your firewall.
       </para>
      </step>
      <step>
       <para>
        Create a directory <filename>/etc/pki/libvirt-vnc</filename> and
        link the certificates into this directory as follows:
       </para>
<screen>mkdir -p /etc/pki/libvirt-vnc &amp;&amp; cd /etc/pki/libvirt-vnc
	ln -s /etc/pki/CA/cacert.pem ca-cert.pem
	ln -s /etc/pki/libvirt/servercert.pem server-cert.pem
	ln -s /etc/pki/libvirt/private/serverkey.pem server-key.pem</screen>
      </step>
      <step>
       <para>
        Edit <filename>/etc/libvirt/qemu.conf</filename> and set the
        following parameters:
       </para>
<screen>vnc_listen = "0.0.0.0"
	vnc_tls = 1
	vnc_tls_x509_verify = 1</screen>
      </step>
      <step>
       <para>
        Restart the &libvirtd;:
       </para>
<screen>rclibvirtd restart</screen>
       <important>
        <title>&vmguest;s Need to be Restarted</title>
        <para>
         The VNC TLS setting is only set when starting a &vmguest;.
         Therefore, you need to restart all machines that have been running
         prior to making the configuration change.
        </para>
       </important>
      </step>
     </procedure>
    </sect4>
    <sect4 id="sec.libvirt.connect.remote.tls.vnc.client">
     <title>VNC over TLS/SSL: Client Configuration</title>
     <para>
      The only action needed on the client side is to place the x509 client
      certificates in a location recognized by the client of choice.
      Unfortunately, each supported client&mdash;&vmm;,
      <command>virt-viewer</command>, and
      <command>vinagre</command>&mdash;expects the certificates in a
      different location. However, &vmm; and <command>vinagre</command> can
      either read from a system wide location applying to all users, or from
      a per user location.
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis role="bold">
	 &vmm; (<command>virt-manager</command>)
	</emphasis>
       </term>
       <listitem>
        <para>
         In order to connect to the remote host, &vmm; requires the setup
         explained in
         <xref linkend="sec.libvirt.connect.remote.tls.client"/>. In order
         to be able to connect via VNC the client certificates also need to
         be placed in the following locations:
        </para>
        <variablelist>
         <varlistentry>
          <term>System wide location</term>
          <listitem>
           <simplelist>
            <member><filename>/etc/pki/CA/cacert.pem</filename>
            </member>
            <member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
            </member>
            <member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
            </member>
           </simplelist>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Per user location</term>
          <listitem>
           <simplelist>
            <member><filename>/etc/pki/CA/cacert.pem</filename>
            </member>
            <member><filename>~/.pki/libvirt-vnc/clientcert.pem</filename>
            </member>
            <member><filename>~/.pki/libvirt-vnc/private/clientkey.pem</filename>
            </member>
           </simplelist>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold"><command>virt-viewer</command></emphasis>
       </term>
       <listitem>
        <para>
         <command>virt-viewer</command> only accepts certificates from a
         system wide location:
        </para>
        <simplelist>
         <member><filename>/etc/pki/CA/cacert.pem</filename>
         </member>
         <member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
         </member>
         <member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
         </member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold"><command>vinagre</command></emphasis>
       </term>
       <listitem>
        <variablelist>
         <varlistentry>
          <term>System wide location</term>
          <listitem>
           <simplelist>
            <member><filename>/etc/pki/CA/cacert.pem</filename>
            </member>
            <member><filename>/etc/pki/vinagre/clientcert.pem</filename>
            </member>
            <member><filename>/etc/pki/vinagre/private/clientkey.pem</filename>
            </member>
           </simplelist>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Per user location</term>
          <listitem>
           <simplelist>
            <member><filename>$HOME/.pki/CA/cacert.pem</filename>
            </member>
            <member><filename>~/.pki/vinagre/clientcert.pem</filename>
            </member>
            <member><filename>~/.pki/vinagre/private/clientkey.pem</filename>
            </member>
           </simplelist>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
      </varlistentry>
     </variablelist>
     <important>
      <title>Restrict Access to Certificates</title>
      <para>
       Make sure to restrict access to certificates as explained in
       <xref linkend="sec.libvirt.connect.remote.tls.security"/>.
      </para>
     </important>
    </sect4>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.security">
    <title>Restricting Access (Security Considerations)</title>
    <para>
     Each x509 certificate consists of two pieces: the public certificate
     and a private key. A client can only authenticate using both pieces.
     Therefore, any user that has read access to the client certificate and
     its private key can access your &vmhost;. On the other hand, an
     arbitrary machine equipped with the full server certificate can pretend
     to be the &vmhost;. Since this is probably not desirable, access to at
     least the private key files needs to be restricted as much as possible.
     The easiest way to control access to a key file is to use access
     permissions.
    </para>
    <variablelist>
     <varlistentry>
      <term><emphasis role="bold">Server Certificates</emphasis>
      </term>
      <listitem>
       <para>
        Server certificates need to be readable for &qemu; processes. On
        &productname; &qemu; processes started from &libvirt; tools are
        owned by &rootuser;, so it is sufficient if &rootuser; is able to
        read them certificates:
       </para>
<screen>chmod 700 /etc/pki/libvirt/private/
chmod 600 /etc/pki/libvirt/private/serverkey.pem</screen>
       <para>
        If you change the ownership for &qemu; processes in
        <filename>/etc/libvirt/qemu.conf</filename>, you also need to adjust
        the ownership of the key file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><emphasis role="bold">System Wide Client Certificates</emphasis>
      </term>
      <listitem>
       <para>
        To control access to a key file that is available system wide,
        restrict read access a certain group, so that only members of that
        group can read the key file. In the following example, a group
        <systemitem class="groupname">libvirt</systemitem> is created and
        the group ownership of the <filename>clientkey.pem</filename> and
        its parent directory is set to
        <systemitem
	 class="groupname">libvirt</systemitem>. Afterwards,
        the access permissions are restricted to owner and group. Finally
        the user &exampleuser; is added to the group
        <systemitem
	 class="groupname">libvirt</systemitem>, so he will be
        able to access the key file.
       </para>
<screen>CERTPATH="/etc/pki/libvirt/"
# create group libvirt
groupadd libvirt
# change ownership to user root and group libvirt
chown root.libvirt $CERTPATH/private $CERTPATH/clientkey.pem
# restrict permissions
chmod 750 $CERTPATH/private
chmod 640 $CERTPATH/private/clientkey.pem
# add user tux to group libvirt
usermod -A libvirt tux
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><emphasis role="bold">Per User Certificates</emphasis>
      </term>
      <listitem>
       <para>
        User specific client certificates for accessing the graphical
        console of a &vmguest; via VNC need to be placed in the users home
        directory in <filename>~/.pki</filename>. Contrary to, for example,
        the VNC viewer using these certificates do not check the access
        permissions of the private key file. Therefore, it is solely on the
        user's responsibility to make sure the key file is not readable by
        others.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <sect4 id="sec.libvirt.connect.remote.tls.server.restrict">
     <title>Restricting Access from the Server Side</title>
     <para>
      By default, every client that is equipped with appropriate client
      certificates may connect to a &vmhost; accepting TLS connections.
      Therefore, it is possible to use additional server side authentication
      with SASL as described in
      <xref
       linkend="sec.libvirt.connect.auth.libvirt.sasl"/>.
     </para>
     <para>
      It is also possible to restrict access with a whitelist of DNs
      (distinguished names), so only clients with a certificate matching a
      DN from the list can connect.
     </para>
     <para>
      Add a list of allowed DNs to <literal>tls_allowed_dn_list</literal> in
      <filename>/etc/libvirt/libvirtd.conf</filename>. This list may contain
      wildcards. Do not specify an empty list, since that would result in
      refusing all connections.
     </para>
<screen>tls_allowed_dn_list = [
   "C=US,L=Provo,O=SUSE Linux Products GmbH,OU=*,CN=&wsIIname;,EMAIL=*",
   "C=DE,L=Nuremberg,O=SUSE Linux Products GmbH,OU=Documentation,CN=*"]</screen>
     <para>
      Get the distinguished name of a certificate with the following
      command:
     </para>
<screen>certtool -i --infile /etc/pki/libvirt/clientcert.pem | grep "Subject:"</screen>
     <para>
      Restart &libvirtd; after having changed the configuration:
     </para>
<screen>rclibvirtd restart</screen>
    </sect4>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.sasl">
    <title>Central User Authentication with SASL for TLS Sockets</title>
<!-- fs 2010-11-11:
     SASL for VNC: https://bugzilla.novell.com/show_bug.cgi?id=652927
-->
    <para>
     A direct user authentication via TLS is not possible - this is handled
     indirectly on each client via the read permissions for the certificates
     as explained in
     <xref
      linkend="sec.libvirt.connect.remote.tls.security"/>.
     However, if a central, server based user authentication is needed
     &libvirt; also allows to use SASL (Simple Authentication and Security
     Layer) on top of TLS for direct user authentication. See
     <xref
      linkend="sec.libvirt.connect.auth.libvirt.sasl"/> for
     configuration details.
    </para>
   </sect3>
   <sect3 id="sec.libvirt.connect.remote.tls.troubleshoot">
    <title>Troubleshooting</title>
    <para/>
    <sect4>
     <title>&vmm;/<command>virsh</command> Cannot Connect to Server</title>
     <para>
      Check the following in the given order:
     </para>
     <simplelist>
      <member>Is it a firewall issue (TCP port 16514 needs to be open on the
       server)?</member>
      <member>Is the client certificate (certificate and key) readable by the
       user that has started
       &vmm;/<command>virsh</command>?
      </member>
      <member>Has the same full qualified hostname as in the server
       certificate been specified with the connection?</member>
      <member>Is TLS enabled on the server (<literal>listen_tls =
	1</literal>)?</member>
      <member>Has &libvirtd; been
       restarted on the server?</member>
     </simplelist>
    </sect4>
    <sect4>
     <title>VNC Connection fails</title>
     <para>
      Ensure that you can basically connect to the remote server using
      &vmm;. If so, check whether the virtual machine on the server has been
      started with TLS support. The virtual machine's name in the following
      example is <quote>sles11</quote>.
     </para>
<screen>ps ax | grep qemu | grep "\-name sles11" | awk -F" -vnc " '{ print FS $2 }'</screen>
     <para>
      If the output does not begin with a string similar to the following,
      the machine has not been started with TLS support and must be
      restarted.
     </para>
<screen> -vnc 0.0.0.0:0,tls,x509verify=/etc/pki/libvirt</screen>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 id="sec.libvirt.connect.connecting">
  <title>Connecting to a &vmhost;</title>

  <para>
   In order to connect to a hypervisor with &libvirt;, you need to specify a
   uniform resource identifier (URI). This URI is needed with
   <command>virsh</command> and <command>virt-viewer</command> (except when
   working as &rootuser; on the &vmhost;) and is optional for the &vmm;.
   Although the latter can be called with a connection parameter (for
   example, <command>virt-manager -c qemu:///system</command>), it also
   offers a graphical interface to create connection URIs. See
   <xref
    linkend="sec.libvirt.connect.connecting.vmm"/> for details.
  </para>

<screen><replaceable>HYPERVISOR</replaceable><co id="co.libvirt.connect.hyperv"/><replaceable>+PROTOCOL</replaceable><co id="co.libvirt.connect.protocol"/>://<replaceable>USER@REMOTE</replaceable><co id="co.libvirt.connect.remote"/>/<replaceable>CONNECTION_TYPE</replaceable><co id="co.libvirt.connect.type"/></screen>

  <calloutlist>
   <callout arearefs="co.libvirt.connect.hyperv">
    <para>
     Specify the hypervisor. &productname; currently supports the following
     hypervisors: <option>test</option> (dummy for testing),
     <option>qemu</option> (&kvm;), and <option>xen</option> (&xen;). This
     parameter is mandatory.
    </para>
   </callout>
   <callout arearefs="co.libvirt.connect.protocol">
    <para>
     When connecting to a remote host, specify the protocol here. Can be one
     of: <option>ssh</option> (connection via SSH tunnel),
     <option>tcp</option> (TCP connection with SASL/Kerberos
     authentication), <option>tls</option> (TLS/SSL encrypted connection
     with authentication via x509 certificates).
    </para>
   </callout>
   <callout arearefs="co.libvirt.connect.remote">
    <para>
     When connecting to a remote host, specify the user and the remote
     hostname. If no user is specified, the username that has called the
     command (<envar>$USER</envar>) is used. Please see below for more
     information. For TLS connections the hostname has to be specified
     exactly as in the x509 certificate.
    </para>
   </callout>
   <callout arearefs="co.libvirt.connect.type">
    <para>
     When connecting to <literal>&qemu;</literal> hypervisor, two
     connections types are accepted: <option>system</option> for full access
     rights, or <option>session</option> for restricted access. Since
     <option>session</option> access is not supported on &productname;, this
     documentation focuses on <option>system</option> access.
    </para>
   </callout>
  </calloutlist>

  <variablelist>
   <title>Example Hypervisor Connection URIs</title>
   <varlistentry>
    <term><option>test:///default</option>
    </term>
    <listitem>
     <para>
      Connect to the local dummy hypervisor. Useful for testing.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>qemu:///system</option>
    </term>
    <listitem>
     <para>
      Connect to the &qemu; hypervisor on the local host having full access
      (type system). This usually requires that the command is issued by the
      user &rootuser;.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>qemu+ssh://&exampleuser;@&wsIVname;/system</option>
    </term>
    <listitem>
     <para>
      Connect to the &qemu; hypervisor on the remote host &wsIVname;. The
      connection is established via an SSH tunnel.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>qemu+tls://&wsIIIname;/system</option>
    </term>
    <listitem>
     <para>
      Connect to the &qemu; hypervisor on the remote host &wsIVname;. The
      connection is established TLS/SSL.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   For more details and examples, refer to the &libvirt; documentation at
   <ulink
    url="http://libvirt.org/uri.html"/>.
  </para>

  <note>
   <title>Usernames in URIs</title>
   <para>
    A username needs to be specified when using Unix socket authentication
    (regardless whether using the username/password authentication scheme or
    &pk;). This applies to all SSH and local connections.
   </para>
   <para>
    There is no need to specify a username when using SASL authentication
    (for TCP or TLS connections) or when doing no additional server side
    authentication for TLS connections. With SASL the username will not be
    evaluated&mdash;you will be prompted for a SASL user/password
    combination in any case.
   </para>
  </note>

  <sect2 id="sec.libvirt.connect.connecting.vmm">
   <title>Managing Connections with &vmm;</title>
   <para>
    The &vmm; uses a <literal>Connection</literal> for every &vmhost; it
    manages. Each connection contains all &vmguest;s on the respective host.
    By default, a connection to the localhost is already configured and
    connected.
   </para>
   <para>
    All configured connections are displayed in the &vmm; main window.
    Active connections are marked with a small triangle which you can click
    in order to fold or unfold the list of &vmguest;s for this connection.
   </para>
   <para>
    Inactive connections are listed gray and are marked with <literal>Not
    Connected</literal>. Either double-click or right-click it and choose
    <guimenu>Connect</guimenu> from the context menu. You can also
    <guimenu>Delete</guimenu> an existing connection from this menu.
   </para>
   <note>
    <title>Editing Existing Connections</title>
    <para>
     It is not possible to edit an existing connection. In order to change a
     connection, create a new one with the desired parameters and delete the
     <quote>old</quote> one.
    </para>
   </note>
   <para>
    To add a new connection in the &vmm;, proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Choose <menuchoice> <guimenu>File</guimenu> <guimenu>Add
      Connection</guimenu> </menuchoice>
     </para>
    </step>
    <step>
     <para>
      Choose the host's <guimenu>Hypervisor</guimenu>
      (<guimenu>Xen</guimenu> or <guimenu>&qemu;/KVM</guimenu>)
     </para>
    </step>
    <step>
     <para>
      Choose a <guimenu>Connection</guimenu> type&mdash;either
      <guimenu>Local</guimenu> for connecting to the host the &vmm; was
      started on, or one of the remote connections (see
      <xref linkend="sec.libvirt.connect.remote"/> for more information).
     </para>
    </step>
    <step>
     <para>
      In case of a remote connection, enter the <guimenu>Hostname</guimenu>
      of the remote machine as <literal>USERNAME@REMOTE_HOST</literal>.
      Usernames must be specified for local connections as well as for SSH
     </para>
     <important>
      <title>Specifying a Username</title>
      <para>
       There is no need to specify a username for TCP and TLS connections;
       it will not be evaluated anyway. A username must be specified for
       local connections as well as for SSH connections&mdash;if not, the
       default user <literal>root</literal> will be used.
      </para>
     </important>
    </step>
    <step>
     <para>
      If you do not want the connection to be automatically activated when
      starting the &vmm;, remove the tick from
      <guimenu>Autoconnect</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Finish the configuration by clicking <guimenu>Connect</guimenu>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
</chapter>
