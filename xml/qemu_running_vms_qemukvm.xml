<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.qemu.running">
 <title>Running Virtual Machines with qemu-kvm</title>
 <para>
  Once you have a virtual disk image ready (for more information on disk
  images, see <xref linkend="cha.qemu.guest_inst.qemu-img"/>), it is time to
  start the related virtual machine.
  <xref linkend="cha.qemu.guest_inst.qemu-kvm"/> introduced simple commands
  to install and run &vmguest;. This chapter focuses on a more detailed
  explanation of <command>qemu-kvm</command> usage, and shows solutions of
  more specific tasks. For a complete list of <command>qemu-kvm</command>'s
  options, see its manual page (<command>man 1 qemu-kvm</command>).
 </para>
 <sect1 id="cha.qemu.running.basic">
  <title>Basic <command>qemu-kvm</command> Invocation</title>

  <para>
   The <command>qemu-kvm</command> command uses the following syntax:
  </para>

<screen>qemu-kvm options<co id="co.qemu.running.basic.opts"/> disk_img<co id="co.qemu.running.basic.img"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu.running.basic.opts">
    <para>
     <command>qemu-kvm</command> understands a large number of options. Most
     of them define parameters of the emulated hardware, while others affect
     more general emulator behavior. If you do not supply any options,
     default values are used, and you need to supply the path to a disk
     image to be run.
    </para>
   </callout>
   <callout arearefs="co.qemu.running.basic.img">
    <para>
     Path to the disk image holding the guest system you want to virtualize.
     <command>qemu-kvm</command> supports a large number of image formats.
     Use <command>qemu-img --help</command> to list them. If you do not
     supply the path to a disk image as a separate argument, you have to use
     the <literal>-drive file=</literal> option.
    </para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 id="cha.qemu.running.gen_opts">
  <title>General <command>qemu-kvm</command> Options</title>

  <para>
   This section introduces general <command>qemu-kvm</command> options and
   options related to the basic emulated hardware, such as virtual machine's
   processor, memory, model type, or time processing methods.
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>-name <replaceable>name_of_guest</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the name of the running guest system. The name is displayed
      in the window caption and also used for the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-boot <replaceable>options</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the order in which the defined drives will be booted. Drives
      are represented by letters, where 'a' and 'b' stands for the floppy
      drives 1 and 2, 'c' stands for the first hard disk, 'd' stands for the
      first CD-ROM drive, and 'n' to 'p' stand for Ether-boot network
      adapters.
     </para>
     <para>
      For example, <literal>qemu-kvm [...] -boot order=ndc</literal> first
      tries to boot from network, then from the first CD-ROM drive, and
      finally from the first hard disk.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-pidfile <replaceable>fname</replaceable></literal>
    </term>
    <listitem>
     <para>
      Stores the &qemu;'s process identification number (PID) in a file.
      This is useful if you run &qemu; from a script.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-nodefaults</literal>
    </term>
    <listitem>
     <para>
      By default &qemu; creates basic virtual devices even if you do not
      specify them on the command line. This option turns this feature off,
      and you must specify every single device manually, including graphical
      and network cards, parallel or serial ports, or virtual consoles. Even
      &qemu; monitor is not attached by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-daemonize</literal>
    </term>
    <listitem>
     <para>
      'Daemonizes' the &qemu; process after it is started. &qemu; will
      detach from the standard input and standard output after it is ready
      to receive connections on any of its devices.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 id="cha.qemu.running.gen_opts.basic">
   <title>Basic Virtual Hardware</title>
   <variablelist>
    <varlistentry>
     <term><literal>-M <replaceable>machine_type</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies the type of the emulated machine. Run <command>qemu-kvm -M
       ?</command> to view a list of supported machine types.
      </para>
<screen>&exampleuser;@&wsII;:~> qemu-kvm -M ?
Supported machines are:
pc         Standard PC (alias of pc-0.12)
pc-0.12    Standard PC (default)
pc-0.11    Standard PC, qemu 0.11
pc-0.10    Standard PC, qemu 0.10
isapc      ISA-only PC
mac        Intel-Mac</screen>
      <note>
       <para>
        Currently, &novell; supports only the default
        <literal>pc-0.12</literal> machine type.
       </para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-m <replaceable>megabytes</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies how many megabytes are used for the virtual RAM size.
       Default is 128 MB.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-balloon virtio</literal>
     </term>
     <listitem>
      <para>
       Specifies a paravirtualized device to dynamically change the amount
       of virtual RAM memory assigned to &vmguest;. The top limit is the
       amount of memory specified with <literal>-m</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-cpu <replaceable>cpu_model</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies the type of the processor (CPU) model. Run
       <command>qemu-kvm -cpu ?</command> to view a list of supported CPU
       models.
      </para>
<screen>&exampleuser;@&wsII;:~> qemu-kvm -cpu ?
x86           qemu64
x86           phenom
x86         core2duo
x86            kvm64
x86           qemu32
x86          coreduo
x86              486
x86          pentium
x86         pentium2
x86         pentium3
x86           athlon
x86             n270</screen>
      <note>
       <para>
        Currently, &novell; supports only the <literal>kvm64</literal> CPU
        model.
       </para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-smp <replaceable>number_of_cpus</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies how many CPUs will be emulated. &qemu; supports up to 255
       CPUs on the PC platform. This option also takes other CPU-related
       parameters, such as number of <emphasis>sockets</emphasis>, number of
       <emphasis>cores</emphasis> per socket, or number of
       <emphasis>threads</emphasis> per core.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Following is an example of a working <command>qemu-kvm</command> command
    line:
   </para>
<screen>qemu-kvm -name "SLES 11 SP1" -M pc-0.12 -m 512 -cpu kvm64 \
-smp 2 /images/sles11sp1.raw</screen>
   <figure>
    <title>&qemu; Window with SLES 11 SP1 as &vmguest;</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <variablelist>
    <varlistentry>
     <term><literal>-no-acpi</literal>
     </term>
     <listitem>
      <para>
       Disables ACPI support. Try to use it if &vmguest; reports problems
       with ACPI interface.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-S</literal>
     </term>
     <listitem>
      <para>
       &qemu; starts with CPU stopped. To start CPU, enter
       <literal>c</literal> in &qemu; monitor. For more information, see
       <xref
        linkend="cha.qemu.monitor"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="cha.qemu.running.gen_opts.storing_cong">
   <title>Storing and Reading Configuration of Virtual Devices</title>
   <variablelist>
    <varlistentry>
     <term><literal>-readconfig <replaceable>cfg_file</replaceable></literal>
     </term>
     <listitem>
      <para>
       Instead of entering the devices configuration options on the command
       line each time you want to run &vmguest;, <command>qemu-kvm</command>
       can read it from a file which was either previously saved with
       <literal>-writeconfig</literal> or edited manually.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-writeconfig <replaceable>cfg_file</replaceable></literal>
     </term>
     <listitem>
      <para>
       Dumps the current virtual machine devices configuration to a text
       file. It can be consequently re-used with the
       <literal>-readconfig</literal> option.
      </para>
<screen>&exampleuser;@&wsII;:~> qemu-kvm -name "SLES 11 SP1" -M pc-0.12 -m 512 -cpu kvm64 \
-smp 2 /images/sles11sp1.raw -writeconfig /images/sles11sp1.cfg
(exited)
&exampleuser;@&wsII;:~> more /images/sles11sp1.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles11sp1_base.raw"</screen>
      <para>
       This way you can effectively manage the configuration of your virtual
       machines' devices in a well-arranged way.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="cha.qemu.running.gen_opts.rtc">
   <title>Guest Real-time Clock</title>
   <variablelist>
    <varlistentry>
     <term><literal>-rtc <replaceable>options</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies the way the RTC is handled inside &vmguest;. By default,
       the clock of &vmguest; is derived from that of the host system.
       Therefore, it is recommended that the host system clock is
       synchronized with an accurate external clock (for example, via NTP
       service).
      </para>
      <para>
       If you need to isolate the &vmguest; clock from the host one, specify
       <literal>clock=vm</literal> instead of the default
       <literal>clock=host</literal>.
      </para>
      <para>
       You can also specify a 'starting point' for &vmguest; clock with the
       <literal>base</literal> option:
      </para>
<screen>qemu-kvm [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
      <para>
       Instead of a timestamp, you can specify <literal>utc</literal> or
       <literal>localtime</literal>. The former instructs &vmguest; to start
       at UTC (Coordinated Universal Time, see
       <ulink url="http://en.wikipedia.org/wiki/Utc"/>), while the latter
       applies the local time setting.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

<!--
  #!/bin/sh
  #set -x
  bridge=br0
  tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)

  /usr/bin/sudo /sbin/ip link set $tap up
  sleep 0.5s
  /usr/bin/sudo /sbin/brctl addif $bridge $tap

  /usr/bin/qemu-kvm -m 512 \
  -boot order=cd,menu=on \
  -drive
  file=/local/kvm/sles11-SP1-vnc15.raw,if=virtio,cache=none,aio=native,boot=on \
  -net nic,model=virtio,macaddr=52:54:00:12:45:80 -net
  tap,ifname=$tap,script=no,downscript=no \
  -vga std \
  -usb -usbdevice tablet \
  -balloon virtio \
  -writeconfig /local/kvm/test.cfn \
  -vnc :15 -k de

  /usr/bin/sudo /sbin/brctl delif $bridge $tap
  /usr/bin/sudo /sbin/ip link set $tap down
  /usr/bin/sudo /bin/tunctl -d $tap
  -->
 </sect1>
 <sect1 id="cha.qemu.running.devices">
  <title>&qemu; Virtual Devices</title>

  <para>
   &qemu; virtual machines emulate all devices needed to run &vmguest;.
   &qemu; supports, for example, several types of network cards, block
   devices (hard and removable drives), USB devices, character devices
   (serial and parallel ports), or multimedia devices (graphic and sound
   cards). For satisfactory operation and performance of the virtual
   machine, some or all of these devices must be configured correctly. This
   section introduces options to configure various types of supported
   devices.
  </para>

  <sect2 id="cha.qemu.running.devices.block">
   <title>Block Devices</title>
   <para>
    Block devices are vital for virtual machines. In general, these are
    fixed or removable storage media usually referred to as 'drives'. One of
    the connected hard drives typically holds the guest operating system to
    be virtualized.
   </para>
   <para>
    Virtual machine drives are defined with <literal>-drive</literal>. This
    option uses many suboptions, some of which are described in this
    section. For their complete list, see the manual page (<literal>man 1
    qemu-kvm</literal>).
   </para>
   <variablelist>
    <title>Suboptions for the <literal>-drive</literal> Option</title>
    <varlistentry>
     <term><literal>file=image_fname</literal>
     </term>
     <listitem>
      <para>
       Specifies the path to the disk image which will be used with this
       drive. If not specified, an empty (removable) drive is assumed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>if=drive_interface</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of interface to which the drive is connected.
       Currently only <literal>floppy</literal>, <literal>ide</literal>, or
       <literal>virtio</literal> are supported by &novell;.
       <literal>virtio</literal> defines a paravirtualized disk driver.
       Default is <literal>ide</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>index=index_of_connector</literal>
     </term>
     <listitem>
      <para>
       Specifies the index number of a connector on the disk interface (see
       the <literal>if</literal> option) where the drive is connected. If
       not specified, the index is automatically incremented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>media=type</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of the media. Can be <literal>disk</literal> for
       hard disks, or <literal>cdrom</literal> for removable CD-ROM drives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>format=img_fmt</literal>
     </term>
     <listitem>
      <para>
       Specifies the format of the connected disk image. If not specified,
       the format is autodetected. Currently, &novell; supports only the
       <literal>raw</literal> format.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>boot='on' or 'off'</literal>
     </term>
     <listitem>
      <para>
       Specifies whether booting from 'uncommon' devices (such as
       <literal>virtio</literal>) is allowed. If not specified, disks
       connected via <literal>virtio</literal> interface will refuse to
       boot.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>cache=method</literal>
     </term>
     <listitem>
      <para>
       Specifies the caching method for the drive. Possible values are
       <literal>unsafe</literal>, <literal>writethrough</literal>,
       <literal>writeback</literal>, or <literal>none</literal>. For the
       <literal>qcow2</literal> image format, choose
       <literal>writeback</literal> if you care about performance.
       <literal>none</literal> disables the host page cache and, therefore,
       is the safest option. Default is <literal>writethrough</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <para>
     To simplify defining of block devices, &qemu; understands several
     shortcuts which you may find handy when entering the
     <literal>qemu-kvm</literal> command line.
    </para>
    <para>
     You can use
    </para>
<screen>qemu-kvm -cdrom /images/cdrom.iso</screen>
    <para>
     instead of
    </para>
<screen>qemu-kvm -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
    <para>
     and
    </para>
<screen>qemu-kvm -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
    <para>
     instead of
    </para>
<screen>qemu-kvm -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
   </tip>
   <tip>
    <title>Using Host Drives Instead of Images</title>
    <para>
     Normally you will use disk images (see
     <xref
      linkend="cha.qemu.guest_inst.qemu-img"/>) as disk drives of
     the virtual machine. However, you can also use existing &vmhost; disks,
     connect them as drives, and access them from &vmguest;. Use the host
     disk device directly instead of disk image filenames.
    </para>
    <para>
     To access the host CD-ROM drive, use
    </para>
<screen>qemu-kvm [...] -drive file=/dev/cdrom,media=cdrom</screen>
    <para>
     To access the host hard disk, use
    </para>
<screen>qemu-kvm [...] -drive file=/dev/hdb,media=disk</screen>
    <para>
     When accessing the host hard drive from &vmguest;, always make sure the
     access is <emphasis>read-only</emphasis>. You can do so by modifying
     the host device permissions.
    </para>
   </tip>
  </sect2>

  <sect2 id="cha.qemu.running.devices.graphic">
   <title>Graphic Devices and Display Options</title>
   <para>
    This section describes &qemu; options affecting the type of the emulated
    video card and the way &vmguest; graphical output is displayed.
   </para>
   <sect3 id="cha.qemu.running.devices.graphic.vga">
    <title>Defining Video Cards</title>
    <para>
     &qemu; uses <literal>-vga</literal> to define a video card used to
     display &vmguest; graphical output. The <literal>-vga</literal> option
     understands the following values:
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>none</literal>
      </term>
      <listitem>
       <para>
        Disables video cards on &vmguest; (no video card is emulated). You
        can still access the running &vmguest; via the &qemu; monitor and
        the serial console.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>std</literal>
      </term>
      <listitem>
       <para>
        Emulates a standard VESA 2.0 VBE video card. Use it if you intend to
        use high display resolution on &vmguest;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>cirrus</literal>
      </term>
      <listitem>
       <para>
        Emulates Cirrus Logic GD5446 video card. Good choice if you insist
        on high compatibility of the emulated video hardware. Most operating
        systems (even Windows 95) recognize this type of card.
       </para>
       <tip>
        <para>
         For best video performance with the <literal>cirrus</literal> type,
         use 16-bit color depth both on &vmguest; and &vmhost;.
        </para>
       </tip>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 id="cha.qemu.running.devices.graphic.display">
    <title>Display Options</title>
    <para>
     The following options affect the way &vmguest; graphical output is
     displayed.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-nographic</literal>
      </term>
      <listitem>
       <para>
        Disables &qemu;'s graphical output. The emulated serial port is
        redirected to the console.
       </para>
       <para>
        After starting the virtual machine with
        <literal>-nographic</literal>, press
        <keycombo><keycap function="control"/><keycap>A</keycap></keycombo>
        <keycap>H</keycap> in the virtual console to view the list of other
        useful shortcuts, for example, to toggle between the console and the
        &qemu; monitor.
       </para>
<screen>&exampleuser;@&wsII;:~> qemu-kvm -hda /images/sles11sp1_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 0.12.5 monitor - type 'help' for more information
(qemu)</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-frame</literal>
      </term>
      <listitem>
       <para>
        Disables decorations for the &qemu; window. Convenient for dedicated
        desktop workspace.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-full-screen</literal>
      </term>
      <listitem>
       <para>
        Starts &qemu; graphical output in full screen mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-quit</literal>
      </term>
      <listitem>
       <para>
        Disables the 'close' button of &qemu; window and prevents it from
        being closed by force.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-alt-grab, -ctrl-grab</literal>
      </term>
      <listitem>
       <para>
        By default &qemu; window releases the 'captured' mouse after
        <keycombo><keycap function="control"/><keycap function="alt"/></keycombo>
        is pressed. You can change the key combination to either
        <keycombo><keycap function="control"/><keycap function="alt"/><keycap function="shift"/></keycombo>
        (<literal>-alt-grab</literal>), or <keycap>Right Ctrl</keycap>
        (<literal>-ctrl-grab</literal>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.devices.usb">
   <title>USB Devices</title>
   <para>
    To emulate USB devices in &qemu; you first need to enable the generic
    USB driver with the <literal>-usb</literal> option. Then you can specify
    individual devices with the <literal>-usbdevice</literal> option.
    Although &qemu; supports much more types of USB devices, &novell;
    currently only supports the types <literal>mouse</literal> and
    <literal>tablet</literal>.
   </para>
   <variablelist>
    <title>Types of USB devices for the <literal>-usbdevice</literal> Option</title>
    <varlistentry>
     <term><literal>mouse</literal>
     </term>
     <listitem>
      <para>
       Emulates a virtual USB mouse. This option overrides the default PS/2
       mouse emulation. The following example shows the hardware status of a
       mouse on &vmguest; started with <literal>qemu-kvm [...] -usbdevice
       mouse</literal>:
      </para>
<screen>&exampleuser;@&wsII;:~> hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>tablet</literal>
     </term>
     <listitem>
      <para>
       Emulates a pointer device that uses absolute coordinates (such as
       touchscreen). This option overrides the default PS/2 mouse emulation.
       The tablet device is useful if you are viewing &vmguest; via the VNC
       protocol. See <xref linkend="cha.qemu.running.vnc"/> for more
       information.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="cha.qemu.running.devices.char">
   <title>Character Devices</title>
   <para>
    Use <literal>-chardev</literal> to create a new character device. The
    option uses the following general syntax:
   </para>
<screen>qemu-kvm [...] -chardev <replaceable>backend_type</replaceable>,id=<replaceable>id_string</replaceable></screen>
   <para>
    where <replaceable>backend_type</replaceable> can be one of
    <literal>null</literal>, <literal>socket</literal>,
    <literal>udp</literal>, <literal>msmouse</literal>,
    <literal>vc</literal>, <literal>file</literal>, <literal>pipe</literal>,
    <literal>console</literal>, <literal>serial</literal>,
    <literal>pty</literal>, <literal>stdio</literal>,
    <literal>braille</literal>, <literal>tty</literal>, or
    <literal>parport</literal>. All character devices must have a unique
    identification string up to 127 characters long. It is used to identify
    the device in other related directives. For the complete description of
    all backend's suboptions, see the man page (<command>man 1
    qemu-kvm</command>). A brief description of the available
    <literal>backends</literal> follows:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>null</literal>
     </term>
     <listitem>
      <para>
       Creates an empty device which outputs no data and drops any data it
       receives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>stdio</literal>
     </term>
     <listitem>
      <para>
       Connects to &qemu;'s process standard input and standard output.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>socket</literal>
     </term>
     <listitem>
      <para>
       Creates a two-way stream socket. If <replaceable>path</replaceable>
       is specified, a Unix socket is created:
      </para>
<screen>qemu-kvm [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
      <para>
       The <replaceable>server</replaceable> suboption specifies that the
       socket is a listening socket.
      </para>
      <para>
       If <replaceable>port</replaceable> is specified, a TCP socket is
       created:
      </para>
<screen>qemu-kvm [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
      <para>
       The command creates a local listening (<literal>server</literal>) TCP
       socket on port 7777. &qemu; will not block waiting for a client to
       connect to the listening port (<literal>nowait</literal>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>udp</literal>
     </term>
     <listitem>
      <para>
       Sends all network traffic from &vmguest; to a remote host over the
       UDP protocol.
      </para>
<screen>qemu-kvm [...] -chardev udp,id=udp_fwd,host=&wsIVname;,port=7777</screen>
      <para>
       The command binds port 7777 on the remote host &wsIVname; and sends
       &vmguest; network traffic there.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>vc</literal>
     </term>
     <listitem>
      <para>
       Creates a new &qemu; text console. You can optionally specify the
       dimensions of the virtual console:
      </para>
<screen>qemu-kvm [...] -chardev vc,id=vc1,width=640,height=480 -mon chardev=vc1</screen>
      <para>
       The command creates a new virtual console called
       <literal>vc1</literal> of the specified size, and connects the &qemu;
       monitor to it.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>file</literal>
     </term>
     <listitem>
      <para>
       Logs all traffic from &vmguest; to a file on &vmhost;. The
       <literal>path</literal> is required and will be created if it does
       not exist.
      </para>
<screen>qemu-kvm [...] -chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    By default &qemu; creates a set of character devices for serial and
    parallel ports, and a special console for &qemu; monitor. You can,
    however, create your own character devices and use them for just
    mentioned purposes. The following options will help you:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>-serial <replaceable>char_dev</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s virtual serial port to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. By default, it is a
       virtual console (<literal>vc</literal>) in graphical mode, and
       <literal>stdio</literal> in non-graphical mode. The
       <literal>-serial</literal> understands many suboptions. See the
       manual page <command>man 1 qemu-kvm</command> for their complete
       list.
      </para>
      <para>
       You can emulate up to 4 serial ports. Use <literal>-serial
       none</literal> to disable all serial ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-parallel <replaceable>device</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s parallel port to a
       <replaceable>device</replaceable>. This option supports the same
       devices as <literal>-serial</literal>.
      </para>
      <tip>
       <para>
        If your &vmhost; is Linux, you can directly use the hardware
        parallel port devices <filename>/dev/parportN</filename> where
        <literal>N</literal> is the number of the port.
       </para>
      </tip>
      <para>
       You can emulate up to 3 parallel ports. Use <literal>-parallel
       none</literal> to disable all parallel ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-monitor <replaceable>char_dev</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &qemu; monitor to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. This option supports
       the same devices as <literal>-serial</literal>. By default, it is a
       virtual console (<literal>vc</literal>) in a graphical mode, and
       <literal>stdio</literal> in non-graphical mode.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 id="cha.qemu.running.networking">
  <title>Networking with &qemu;</title>

  <para>
   Use the <literal>-net</literal> option to define a network interface and
   a specific type of networking for your &vmguest;. Currently, &novell;
   supports the following options: <literal>none</literal>,
   <literal>nic</literal>, <literal>user</literal>, and
   <literal>tap</literal>. For a complete list of <literal>-net</literal>
   suboptions, see the man page (<command>man 1 qemu-kvm</command>).
  </para>

  <variablelist>
   <title>Supported <literal>-net</literal> Suboptions</title>
   <varlistentry>
    <term><literal>none</literal>
    </term>
    <listitem>
     <para>
      Disables a network card emulation on &vmguest;. Only the loopback
      <literal>lo</literal> network interface is available.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>nic</literal>
    </term>
    <listitem>
     <para>
      Creates a new Network Interface Card (NIC) and connects it to a
      specified Virtual Local Area Network (VLAN). For more information, see
      <xref linkend="cha.qemu.running.networking.nic"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal>
    </term>
    <listitem>
     <para>
      Specifies a user-mode networking. For more information , see
      <xref
       linkend="cha.qemu.running.networking.usermode"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tap</literal>
    </term>
    <listitem>
     <para>
      Specifies a bridged networking. For more information, see
      <xref
       linkend="cha.qemu.running.networking.bridge"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 id="cha.qemu.running.networking.nic">
   <title>Defining a Network Interface Card</title>
   <para>
    Use <literal>-net nic</literal> to add a new emulated network card:
   </para>
<screen>qemu-kvm [...] -net nic,vlan=1<co id="co.qemu.running.networking.nic.vlan"/>,macaddr=&wsIVmac;<co id="co.qemu.running.networking.nic.mac"/>,\
model=virtio<co id="co.qemu.running.networking.nic.model"/>,name=ncard1<co id="co.qemu.running.networking.nic.name"/></screen>
   <calloutlist>
    <callout arearefs="co.qemu.running.networking.nic.vlan">
     <para>
      Connects the network interface to VLAN number 1. You can specify your
      own number, it is mainly useful for identification purpose. If you
      omit this suboption, &qemu; uses the default 0.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.mac">
     <para>
      Specifies the Media Access Control (MAC) address for the network card.
      It is a unique identifier and you are advised to always specify it. If
      not, &qemu; supplies its own default MAC address and creates a
      possible MAC address conflict within the related VLAN.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.model">
     <para>
      Specifies the model of the network card. Use <literal>-net
      nic,model=?</literal> to get the list of all network card models
      supported by &qemu; on your platform:
     </para>
     <para>
      Currently, &novell; supports the models <literal>rtl8139</literal> and
      <literal>virtio</literal>.
     </para>
    </callout>
   </calloutlist>
  </sect2>

  <sect2 id="cha.qemu.running.networking.usermode">
   <title>User-mode Networking</title>
   <para>
    The <literal>-net user</literal> option instructs &qemu; to use a
    user-mode networking. This is the default if no networking mode is
    selected. Therefore, these command lines are equivalent:
   </para>
<screen>qemu-kvm -hda /images/sles11sp1_base.raw</screen>
<screen>qemu-kvm -hda /images/sles11sp1_base.raw -net nic -net user</screen>
   <para>
    This mode is useful if you want to allow &vmguest; to access the
    external network resources, such as Internet. By default, no incoming
    traffic is permitted and therefore, &vmguest; is not visible to other
    machines on the network. No administrator privileges are required in
    this networking mode. The user-mode is also useful to do a
    'network-booting' on your &vmguest; from a local directory on &vmhost;.
   </para>
   <para>
    The &vmguest; allocates an IP address from a virtual DHCP server.
    &vmhost; (the DHCP server) is reachable at 10.0.2.2, while the IP
    address range for allocation starts from 10.0.2.15. You can use
    <command>ssh</command> to connect to &vmhost; at 10.0.2.2, and
    <command>scp</command> to copy files back and forth.
   </para>
   <sect3 id="cha.qemu.running.networking.usermode.examples">
    <title>Command Line Examples</title>
    <para>
     This section shows several examples on how to set up user-mode
     networking with &qemu;.
    </para>
    <example id="ex.qemu.net.usermode.resctrict">
     <title>Restricted User-mode Networking</title>
<screen>qemu-kvm [...] -net user<co id="co.usermode.user"/>,vlan=1<co id="co.usermode.vlan"/>,name=user_net1<co id="co.usermode.name"/>,restrict=yes<co id="co.usermode.restrict"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.user">
       <para>
        Specifies user-mode networking.
       </para>
      </callout>
      <callout arearefs="co.usermode.vlan">
       <para>
        Connect to VLAN number 1. If omitted, defaults to 0.
       </para>
      </callout>
      <callout arearefs="co.usermode.name">
       <para>
        Specifies a human readable name of the network stack. Useful when
        identifying it in the &qemu; monitor.
       </para>
      </callout>
      <callout arearefs="co.usermode.restrict">
       <para>
        Isolates &vmguest;. It will not be able to communicate with &vmhost;
        and no network packets will be routed to the external network.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.iprange">
     <title>User-mode Networking with Custom IP Range</title>
<screen>qemu-kvm [...] -net user,net=10.2.0.0/8<co id="co.usermode.net"/>,host=10.2.0.6<co id="co.usermode.host"/>,dhcpstart=10.2.0.20<co id="co.usermode.dhcpstart"/>,\
hostname=tux_kvm_guest<co id="co.usermode.hostname"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.net">
       <para>
        Specifies the IP address of the network that &vmguest; sees and
        optionally the netmask. Default is 10.0.2.0/8.
       </para>
      </callout>
      <callout arearefs="co.usermode.host">
       <para>
        Specifies the &vmhost; IP address that &vmguest; sees. Default is
        10.0.2.2.
       </para>
      </callout>
      <callout arearefs="co.usermode.dhcpstart">
       <para>
        Specifies the first of the 16 IP addresses that the built-in DHCP
        server can assign to &vmguest;. Default is 10.0.2.15.
       </para>
      </callout>
      <callout arearefs="co.usermode.hostname">
       <para>
        Specifies the hostname that the built-in DHCP server will assign to
        &vmguest;.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.netboot_tftp">
     <title>User-mode Networking with Network-boot and TFTP</title>
<screen>qemu=kvm [...] -net user,tftp=/images/tftp_dir<co id="co.usermode.tftp"/>,bootfile=/images/boot/pxelinux.0<co id="co.usermode.bootfile"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.tftp">
       <para>
        Activates a built-in TFTP (a file transfer protocol with the
        functionality of a very basic FTP) server. The files in the
        specified directory will be visible to &vmguest; as the root of a
        TFTP server.
       </para>
      </callout>
      <callout arearefs="co.usermode.bootfile">
       <para>
        Broadcasts the specified file as a BOOTP (a network protocol which
        offers an IP address and a network location of a boot image, often
        used in diskless workstations) file. When used together with
        <literal>tftp</literal>, &vmguest; can boot from network from the
        local directory on the host.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.hostfwd">
     <title>User-mode Networking with Host Port Forwarding</title>
<screen>qemu-kvm [...] -net user,hostfwd=tcp::2222-:22</screen>
     <para>
      Forwards incoming TCP connections to the port 2222 on the host to the
      port 22 (<systemitem class="service">SSH</systemitem>) on &vmguest;.
      If <systemitem class="daemon">sshd</systemitem> is running on
      &vmguest;, enter
     </para>
<screen>ssh qemu_host -p 2222</screen>
     <para>
      where <literal>qemu_host</literal> is the hostname or IP address of
      the host system, to get a <systemitem class="daemon">SSH</systemitem>
      prompt from &vmguest;.
     </para>
    </example>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.networking.bridge">
   <title>Bridged Networking</title>
   <para>
    With the <literal>-net tap</literal> option, &qemu; creates a network
    bridge by connecting the host TAP network device to a specified VLAN of
    &vmguest;. Its network interface is then visible to the rest of the
    network. This method does not work by default and has to be explicitly
    specified.
   </para>
   <para>
    First, create a network bridge and add a &vmhost; physical network
    interface (usually <literal>eth0</literal>) to it:
   </para>
   <procedure>
    <step>
     <para>
      Start &yastcc; and select <menuchoice><guimenu>Network
      Devices</guimenu><guimenu>Network Settings</guimenu></menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add</guimenu> and select <guimenu>Bridge</guimenu> from
      the <guimenu>Device Type</guimenu> drop-down list in the
      <guimenu>Hardware Dialog</guimenu> window. Click
      <guimenu>Next</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Choose whether you need a dynamically or statically assigned IP
      address, and fill the related network settings if applicable.
     </para>
    </step>
    <step>
     <para>
      In the <guimenu>Bridged Devices</guimenu> pane, select the Ethernet
      device to add to the bridge.
     </para>
     <figure>
      <title>Configuring Network Bridge with &yast;</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      Click <guimenu>Next</guimenu>. If asked about adapting already
      configured device, click <guimenu>Continue</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>OK</guimenu> to apply the changes. Check if the bridge
      is created:
     </para>
<screen>&exampleuser;@&wsII;:~> brctl show
bridge name bridge id          STP enabled  interfaces
br0         8000.001676d670e4  no           eth0</screen>
    </step>
   </procedure>
   <para>
    Use the following example script to connect &vmguest; to the newly
    created bridge interface <literal>br0</literal>. Several commands in the
    script are run via the <command>sudo</command> mechanism because they
    require &rootuser; privileges.
   </para>
   <note>
    <para>
     Make sure the <systemitem>tunctl</systemitem> and
     <systemitem>bridge-utils</systemitem> packages are installed on
     &vmhost;. If not, install them with <command>zypper in tunctl
     bridge-utils</command>.
    </para>
   </note>
<screen>
#!/bin/bash
bridge=br0<co id="co.qemu.net.bridge.br"/>
tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)<co id="co.qemu.net.bridge.tap"/>
/usr/bin/sudo /sbin/ip link set $tap up<co id="co.qemu.net.bridge.up"/>
sleep 1s<co id="co.qemu.net.bridge.sleep"/>
/usr/bin/sudo /sbin/brctl addif $bridge $tap<co id="co.qemu.net.bridge.br3"/>
qemu-kvm -m 512 -hda /images/sles11sp1_base.raw \
-net nic,vlan=0,model=virtio,macaddr=&wsIVmac; \
-net tap,vlan=0,ifname=$tap<co id="co.qemu.net.bridge.ifname"/>,script=no<co id="co.qemu.net.bridge.script"/>,downscript=no
/usr/bin/sudo /sbin/brctl delif $bridge $tap<co id="co.qemu.net.bridge.delif"/>
/usr/bin/sudo /sbin/ip link set $tap down<co id="co.qemu.net.bridge.linkdown"/>
/usr/bin/sudo /bin/tunctl -d $tap<co id="co.qemu.net.bridge.deltap"/>
</screen>
   <calloutlist>
    <callout arearefs="co.qemu.net.bridge.br">
     <para>
      Name of the bridge device.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.tap">
     <para>
      Prepare a new TAP device and assign it to the user who runs the
      script. TAP devices are virtual network devices often used for
      virtualization and emulation setups.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.up">
     <para>
      Bring up the newly created TAP network interface.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.sleep">
     <para>
      Make a 1 second pause to make sure the new TAP network interface is
      really up.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.br3">
     <para>
      Add the new <literal>TAP</literal> device to the network bridge
      <literal>br0</literal>.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.ifname">
     <para>
      The <literal>ifname=</literal> suboption specifies the name of the TAP
      network interface used for bridging.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.script">
     <para>
      Before <command>qemu-kvm</command> connects to a network bridge, it
      checks the <literal>script</literal> and <literal>downscript</literal>
      values. If it finds the specified scripts on the &vmhost; filesystem,
      it runs the <literal>script</literal> before it connects to the
      network bridge and <literal>downscript</literal> after it exits the
      network environment. You can use these scripts to first set up and
      bring up the bridged network devices, and then to deconfigure them. By
      default, <filename>/etc/qemu-ifup</filename> and
      <filename>/etc/qemu-ifdown</filename> are examined. If
      <literal>script=no</literal> and <literal>downscript=no</literal> are
      specified, the script execution is disabled and you have to take care
      manually.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.delif">
     <para>
      Deletes the TAP interface from a network bridge
      <literal>br0</literal>.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.linkdown">
     <para>
      Sets the state of the TAP device to 'down'.
     </para>
    </callout>
    <callout arearefs="co.qemu.net.bridge.deltap">
     <para>
      Deconfigures the TAP device.
     </para>
    </callout>
   </calloutlist>
<!-- http://blog.alantan.com/2007/01/qemu-tap-bridge-network-configuration.html
   tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)
   /sbin/ip link set $tap up
   /sbin/brctl addbr br0
   /sbin/brctl addif br0 $tap
   /sbin/brctl addif br0 eth0
   /sbin/ip link set br0 up
   -->
  </sect2>
 </sect1>
 <sect1 id="cha.qemu.running.vnc">
  <title>Viewing &vmguest; with&nbsp;VNC</title>

  <para>
   &qemu; normally uses an SDL (a cross-platform multimedia library) window
   to display the graphical output of &vmguest;. With the
   <literal>-vnc</literal> option specified, you can make &qemu; listen on a
   specified VNC display and redirect its graphical output to the VNC
   session.
  </para>

  <tip>
   <para>
    When working with &qemu;'s virtual machine via VNC session, it is useful
    to work with the <literal>-usbdevice tablet</literal> option.
   </para>
   <para>
    Moreover, if you need to use another keyboard layout than the default
    <literal>en-us</literal>, specify it with the <literal>-k</literal>
    option.
   </para>
  </tip>

  <para>
   The first suboption of <literal>-vnc</literal> must be a
   <emphasis>display</emphasis> value. The <literal>-vnc</literal> option
   understands the following display specifications:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>host:display</literal>
    </term>
    <listitem>
     <para>
      Only connections from <literal>host</literal> on the display number
      <literal>display</literal> will be accepted. The TCP port on which the
      VNC session is then running is normally a 5900 +
      <literal>display</literal> number. If you do not specify
      <literal>host</literal>, connections will be accepted from any host.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>unix:path</literal>
    </term>
    <listitem>
     <para>
      The VNC server listens for connections on Unix domain sockets. The
      <literal>path</literal> option specifies the location of the related
      Unix socket.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>none</literal>
    </term>
    <listitem>
     <para>
      The VNC server functionality is initialized, but the server itself is
      not started. You can start the VNC server later with the &qemu;
      monitor. For more information, see <xref linkend="cha.qemu.monitor"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<screen>&exampleuser;@&wsII;:~> qemu-kvm [...] -vnc :5
(on the client:)
&exampleuserII;@&wsI;:~> vinagre &wsII;:5905 &amp;</screen>

  <figure>
   <title>&qemu; VNC Session</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <sect2 id="cha.qemu.running.vnc.secure">
   <title>Secure VNC Connections</title>
   <para>
    The default VNC server setup does not use any form of authentication. In
    the previous example, any user can connect and view the &qemu; VNC
    Session from any host on the network.
   </para>
   <para>
    There are several levels of security which you can apply to your VNC
    client/server connection. You can either protect your connection with a
    password, use x509 certificates, use SASL authentication, or even
    combine some of these authentication methods in one &qemu; command.
   </para>
   <para>
    See <xref linkend="app.kvm.certificates"/> for more information about
    the x509 certificates generation. For more information about configuring
    x509 certificates on &vmhost; and the client, see
    <xref
    linkend="sec.libvirt.connect.remote.tls"/> and
    <xref
    linkend="sec.libvirt.connect.remote.tls.client"/>.
   </para>
   <para>
    The Vinagre VNC viewer supports advanced authentication mechanisms.
    Therefore, it will be used to view the graphical output of &vmguest; in
    the following examples. For this example, lets assume that the server
    x509 certificates <filename>ca-cert.pem</filename>,
    <filename>server-cert.pem</filename>, and
    <filename>server-key.pem</filename> are located in the
    <filename>/etc/pki/qemu</filename> directory on the host, while the
    client's certificates are distributed in the following locations on the
    client:
   </para>
   <simplelist>
    <member><filename>/etc/pki/CA/cacert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
    </member>
   </simplelist>
   <example id="ex.running.vnc.secure.pwd">
    <title>Password Authentication</title>
<screen>qemu-kvm [...] -vnc :5,password -monitor stdio</screen>
    <para>
     Starts the &vmguest; graphical output on VNC display number 5 (usually
     port 5905). The <literal>password</literal> suboption initializes a
     simple password-based authentication method. There is no password set
     by default and you have to set one with the <command>change vnc
     password</command> command in &qemu; monitor:
    </para>
<screen>QEMU 0.12.5 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
    <para>
     You need the <literal>-monitor stdio</literal> option here, because you
     would not be able to manage the &qemu; monitor without redirecting its
     input/output.
    </para>
   </example>
   <figure>
    <title>Authentication Dialog in Vinagre</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="ex.running.vnc.secure.x509">
    <title>x509 Certificate Authentication</title>
    <para>
     The &qemu; VNC server can use TLS encryption for the session and x509
     certificates for authentication. The server asks the client for a
     certificate and validates it against the CA certificate. Use this
     authentication type if your company provides an internal certificate
     authority.
    </para>
<screen>qemu-kvm [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
   </example>
   <example id="ex.running.vnc.secure.pwd_x509">
    <title>x509 Certificate and Password Authentication</title>
    <para>
     You can combine the password authentication with TSL encryption and
     x509 certificate authentication to create a two-layer authentication
     model for clients. Remember to set the password in the &qemu; monitor
     after you run the following command:
    </para>
<screen>qemu-kvm [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu -monitor stdio</screen>
   </example>
   <example id="ex.running.vnc.secure.sasl">
    <title>SASL Authentication</title>
    <para>
     Simple Authentication and Security Layer (SASL) is a framework for
     authentication and data security in Internet protocols. It integrates
     several authentication mechanisms, like PAM, Kerberos, LDAP and more.
     SASL keeps its own user database, so the connecting user accounts do
     not need to exist on &vmhost;.
    </para>
    <para>
     For security reasons, you are advised to combine SASL authentication
     with TLS encryption and x509 certificates:
    </para>
<screen>qemu-kvm [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
   </example>
  </sect2>
 </sect1>
</chapter>
